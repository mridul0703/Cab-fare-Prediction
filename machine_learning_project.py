# -*- coding: utf-8 -*-
"""Machine_Learning_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/mridul0703/Cab-fare-Prediction/blob/main/Machine_Learning_Project.ipynb

# Dataset: new-york-city-taxi-fare-prediction

# Load Dataset
"""

# Import libraries
import numpy as np
import pandas as pd
import csv
import re
import seaborn as sns
import matplotlib.pyplot as plt
import gc
import time
from math import radians, cos, sin, asin, sqrt
from shapely.geometry import Point
from shapely.geometry.polygon import Polygon

# Read data in pandas dataframe, skipping lines
def dataloader(path, step):
  def skip_rows(index):
      if index % step == 0 or index == 0:
        return False
      else:
        return True
  # Keep last n samples for test
  df =  pd.read_csv(path, skiprows = lambda x: skip_rows(x), parse_dates=['pickup_datetime'])
  return df

df = dataloader('train.csv',step=70)

"""# Preprocessing

## Feature Extraction
"""

df['year'] = df.pickup_datetime.apply(lambda t: t.year)
df['month'] = df.pickup_datetime.apply(lambda t: t.month)
df['weekday'] = df.pickup_datetime.apply(lambda t: t.weekday())
df['weekend'] = df['weekday'].apply(lambda t: 1 if t in [5,6] else 0)
df['hour'] = df.pickup_datetime.apply(lambda t: t.hour)
df['minute'] = df.pickup_datetime.apply(lambda t: t.minute)

df['month_sin'] = np.sin((df['month'] - 1) * (2. * np.pi / 12))
df['weekday_sin'] = np.sin((df['weekday'] - 1) * (2. * np.pi / 7))
df['hour_sin'] = np.sin((df['hour'] + df['minute'] / 60) * (2. * np.pi / 24))

# abs of delta of longitude and latitude pickup-dropoff
df['delta_longitude'] = abs(df.pickup_longitude - df.dropoff_longitude)
df['delta_latitude'] = abs(df.pickup_latitude - df.dropoff_latitude)
# peak_hours
df['peak_hours'] = df['hour'].apply(lambda x: 1 if x in [18,19,20] else 0)

# Function to find direction in degrees (Source: https://gist.github.com/jeromer/2005586)
def get_direction(lat1, lon1, lat2, lon2):
  lon1=lon1.to_numpy()
  lat1=lat1.to_numpy()
  lon2=lon2.to_numpy()
  lat2=lat2.to_numpy()
  diff_lon = np.deg2rad(lon2-lon1)
  x = np.sin(diff_lon) * np.cos(lat2)
  y = np.cos(lat1) * np.sin(lat2) - (np.sin(lat1) * np.cos(lat2) * np.cos(diff_lon))
  initial_bearing = np.arctan2(x, y)

  # Now we have the initial bearing but math.atan2 return values
  # from -180° to + 180°.
  direction = np.degrees (initial_bearing)
  # Now we have the initial bearing but math.atan2 return values
  # from -180° to + 180° which is not what we want for a compass bearing
  # The solution is to normalize the initial bearing as shown below
  initial_bearing = np.degrees (initial_bearing)
  direction = (initial_bearing + 360) % 360
  return direction


# Haversine Formula, distance calculation (between pick-up and drop-off coordinates)
#(Source: https://www.igismap.com/haversine-formula-calculate-geographic-distance-earth/)
def haversine(lat1, lon1, lat2, lon2):
  # convert decimal degrees to radians
  lon1=np.deg2rad(lon1.to_numpy())
  lat1=np.deg2rad(lat1.to_numpy())
  lon2=np.deg2rad(lon2.to_numpy())
  lat2=np.deg2rad(lat2.to_numpy())
  # haversine formula
  dlon = lon2 - lon1
  dlat = lat2 - lat1
  a = np.sin(dlat/2)**2 + np.cos(lat1) * np.cos(lat2) * np.sin(dlon/2)**2
  c = 2 * np.arcsin(np.sqrt(a))
  r = 6372.8 # Radius of earth in kilometers. Use 3956 for miles
  return np.around(c * r, decimals=2)


# Load file with polygon coordinates
def merge(list1, list2):
  merged_list = [(list1[i], list2[i]) for i in range(0, len(list1))]
  return merged_list


# Function to find points pick_up at airports
def in_airport(x1,y1,x2,y2,airport):
  for icoord, (x,y) in enumerate(zip([x1,x2], [y1,y2])):
    point = Point(float(x), float(y))
    found = 0
    polygon = Polygon(airport)
    if polygon.contains(point) == True:
      found = 1
      return found
  return found

# Function for fares from/to Manhattan
def in_manhattan(manhattan, x, y):
  point = Point(float(x), float(y))
  found = 0
  polygon = Polygon(manhattan)
  if polygon.contains(point) == 1:
    found = 1
    return found
  return found

# Create columns 'direction', 'distance_km'
df['direction'] = get_direction(df['pickup_latitude'], df['pickup_longitude'], \
                                      df['dropoff_latitude'], df['dropoff_longitude'])

df['distance_km'] = haversine(df['pickup_latitude'], df['pickup_longitude'], \
                                      df['dropoff_latitude'], df['dropoff_longitude'])


# Load data coordinates for NYC airports
JFK = open('JFK2.txt','r')
LAGUARDIA = open('LaGuardia2.txt','r')
NEWARK = open('Newark2.txt','r')
airports = []

jfk_coords = (40.639722, -73.778889)
lga_coords = (40.77725, -73.872611)
nwk_coords = (40.6925, -74.168611)

for airport in [JFK, LAGUARDIA,NEWARK]:
  for line in airport:
    line = line.split(',')
    polygon_y = [ np.float64(i) for i in line[::2] ]
    polygon_x = [ np.float64(i) for i in line[1::2] ]
    airports.append(merge(polygon_x, polygon_y))

# Find how many fares begin/end at an airport
df['JFK']=df.apply(lambda x: in_airport(x['dropoff_latitude'], x['dropoff_longitude'], x['pickup_latitude'], x['pickup_longitude'], airports[0]),axis=1)
df['LGA']=df.apply(lambda x: in_airport(x['dropoff_latitude'], x['dropoff_longitude'], x['pickup_latitude'], x['pickup_longitude'], airports[1]),axis=1)
df['NWK']=df.apply(lambda x: in_airport(x['dropoff_latitude'], x['dropoff_longitude'], x['pickup_latitude'], x['pickup_longitude'], airports[2]),axis=1)


# Load data coordinates for Manhattan
manhattan_ = open('Manhattan.txt','r')
for line in manhattan_:
  line = line.split(',')
  polygon_y = [ np.float64(i) for i in line[::2] ]
  polygon_x = [ np.float64(i) for i in line[1::2] ]
  manhattan = (merge(polygon_x, polygon_y))
manhattan_.close()

# Find how many fares begin/end at Manhattan
df['dropoff_manhattan'] = df.apply(lambda x: in_manhattan(manhattan, x['dropoff_latitude'], x['dropoff_longitude']),axis=1)
df['pickup_manhattan'] = df.apply(lambda x: in_manhattan(manhattan, x['pickup_latitude'], x['pickup_longitude']),axis=1)

# Take inflation into account
def inflation(infl, df1, df2):
  inflated_fare = [0 for i in range(len(df1))]
  inflated_fare = df2['year'].map(infl) * df1#.fare_amount
  res = inflated_fare
  return res

def inverse_inflation(infl, df1, df2):
  inflated_fare = [0 for i in range(len(df1))]
  inflated_fare = df1 / df2['year'].map(infl)
  res = inflated_fare
  return res

#Scaling inflation to 2009 values
infl = {
    2009: 1/1.    ,
    2010: 1/1.0164,
    2011: 1/1.0485,
    2012: 1/1.0702,
    2013: 1/1.0859,
    2014: 1/1.1035,
    2015: 1/1.1048
}

df['inflated_fare'] = inflation(infl, df['fare_amount'], df)

"""## Clean Data


"""

print(df)

"""### General

*   Drop Nan values
*   Drop negative value 'fare_amount' and over 200 $
*   Drop 'passenger_count' value under 1 and over 7
*   Drop outliers with low 'distance_km' and high 'fare_amount'
*   Drop outliers in coordinates
*   Drop 'key' column
"""

print('Old size: %d' % len(df))
df= df.dropna(how = 'any', axis = 'rows')
df = df[(df['fare_amount']>0) & (df['fare_amount']<200)]
df = df[(df['passenger_count']>0) & (df['passenger_count']<=12)]
df = df[-((df['fare_amount']>70) & (df['distance_km']<5))]
df = df[df['distance_km']!=0]

df = df[(df['pickup_longitude']<-65) & (-85<df['pickup_longitude'])]
df = df[(30<df['pickup_latitude']) & (df['pickup_latitude']<55)]

df = df[(df['dropoff_longitude']<-65) & (-85<df['dropoff_longitude'])]
df = df[(30<df['dropoff_latitude']) & (df['dropoff_latitude']<55)]

df = df.drop(columns='key')
print('New size: %d' % len(df))

"""###  Geospatial Data

Plot Geospatial Data
"""

def plot_geodata(df, box, nyc_map, s=10, alpha=0.2):
  fig, axs = plt.subplots(1, 2, figsize=(16,10))
  axs[0].scatter(df.pickup_longitude, df.pickup_latitude, zorder=1, alpha=alpha, c='g', s=s)
  axs[0].set_xlim((box[0], box[1]))
  axs[0].set_ylim((box[2], box[3]))
  axs[0].set_title('Pickup locations')
  axs[0].imshow(nyc_map, zorder=0, extent=box)

  axs[1].scatter(df.dropoff_longitude, df.dropoff_latitude, zorder=1, alpha=alpha, c='g', s=s)
  axs[1].set_xlim((box[0], box[1]))
  axs[1].set_ylim((box[2], box[3]))
  axs[1].set_title('Dropoff locations')
  axs[1].imshow(nyc_map, zorder=0, extent=box)

def select_within_boundingbox(df, box):
  return (df.pickup_longitude >= box[0]) & (df.pickup_longitude <= box[1]) & \
           (df.pickup_latitude >= box[2]) & (df.pickup_latitude <= box[3]) & \
           (df.dropoff_longitude >= box[0]) & (df.dropoff_longitude <= box[1]) & \
           (df.dropoff_latitude >= box[2]) & (df.dropoff_latitude <= box[3])

def lonlat_to_xy(longitude, latitude, dx, dy, box):
  return (dx*(longitude - box[0])/(box[1]-box[0])).astype('int'), \
              (dy - dy*(latitude - box[2])/(box[3]-box[2])).astype('int')

def remove_datapoints_from_water(df):
  # define bounding box
  box = (-74.5, -72.8, 40.5, 41.8)

  # read nyc mask and turn into boolean map with
  # land = True, water = False
  nyc_mask = plt.imread('https://aiblog.nl/download/nyc_mask-74.5_-72.8_40.5_41.8.png')[:,:,0] > 0.9

  # calculate for each lon,lat coordinate the xy coordinate in the mask map
  pickup_x, pickup_y = lonlat_to_xy(df['pickup_longitude'], df['pickup_latitude'],
                                      nyc_mask.shape[1], nyc_mask.shape[0], box)
  dropoff_x, dropoff_y = lonlat_to_xy(df['dropoff_longitude'], df['dropoff_latitude'],
                                      nyc_mask.shape[1], nyc_mask.shape[0], box)
  # calculate boolean index
  idx = (nyc_mask[pickup_y, pickup_x] & nyc_mask[dropoff_y, dropoff_x])

  # return only datapoints on land
  return df[idx]

"""As can be seen from the map above, some samples are located in the water, so we can remove them.
(source https://www.kaggle.com/breemen/nyc-taxi-fare-data-exploration)

Clear and plot the new data

## General Analysis
"""

# check statistics of the features
df.describe()

"""## Feature Interaction"""

plt.figure(figsize = (18,8))
corr = df.corr()
corr
sns.heatmap(corr, annot = True)

"""## Plots"""

# Plot histogram of passengers
df.passenger_count.hist(bins=15, figsize=(14,3))
plt.xlabel('No of passengers')
plt.title('Histogram of number of passengers');

# matplotlib inline
plt.style.use('seaborn-whitegrid')

# Plot histogram of fare
df.fare_amount.hist(bins=200, figsize=(14,3))
plt.xlabel('Fare in $USD')
plt.title('Histogram of fare amount');

# Plot histogram of fares per hour
plt.figure(figsize = (10,5))
new_df = df.groupby('hour', as_index = False)['fare_amount'].agg(['count']).sort_values(by = 'hour', ascending = True)
ax = sns.barplot(x=new_df.index, y=new_df['count'])
ax.set(xlabel='Hour', ylabel='No of fares')
plt.title('Number of fares per hour')
plt.tight_layout()
plt.show()
del new_df
gc.collect()

# Plot histogram of fares per weekday
plt.figure(figsize = (10,5))
new_df = df.groupby('weekday', as_index = False)['fare_amount'].agg(['count']).sort_values(by = 'weekday', ascending = True)
ax = sns.barplot(x=new_df.index, y=new_df['count'])
ax.set(xlabel='weekday', ylabel='No of fares')
plt.title('Number of fares per weekday')
plt.tight_layout()
plt.show()
del new_df
gc.collect()

# Plot histogram of fares per weekday
plt.figure(figsize = (10,5))
new_df = df.groupby('weekday', as_index = False)['fare_amount'].agg(['mean']).sort_values(by = 'weekday', ascending = True)
ax = sns.barplot(x=new_df.index, y=new_df['mean'])
ax.set(xlabel='weekday', ylabel='Fare amount ($)')
plt.title('Mean fare amount ($) per weekday')
plt.tight_layout()
plt.show()
del new_df
gc.collect()

plt.figure(figsize = (10,5))
sns.distplot(df["distance_km"],color = "b")
plt.axvline(df["distance_km"].mean(),color = "k",
            linestyle = "dashed",label = "Avg trip distance (km)")
plt.title("Distribution of trip distance in kilometers")
plt.legend(loc = "best",prop = {"size" : 12})
plt.show()

"""# Machine Learning"""

# Import libraries
from sklearn.model_selection import train_test_split
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import GridSearchCV

from sklearn.svm import SVR
from sklearn.ensemble import BaggingRegressor
from sklearn import linear_model
from sklearn.linear_model import LinearRegression
import xgboost as xgb
from sklearn.ensemble import VotingRegressor
from sklearn.ensemble import RandomForestRegressor
from sklearn.experimental import enable_hist_gradient_boosting
from sklearn.ensemble import HistGradientBoostingRegressor

import keras
from keras.datasets import mnist
from keras.initializers import TruncatedNormal
from keras.layers import Conv2D, Dense, Flatten, Input, MaxPooling2D
from keras.models import Model, Sequential
from keras.optimizers import Adam
import keras.backend as K
import keras.optimizers as opt

import time
from sklearn import metrics

"""#### Split Data into Train, Test set"""

# Columns
#fare_amount  pickup_datetime 	pickup_longitude 	pickup_latitude 	dropoff_longitude 	dropoff_latitude 	passenger_count 	year 	month 	weekday 	hour 	minute 	delta_longitude 	delta_latitude 	peak_hours 	distance_km 	direction 	JFK 	LGA 	NWK 	inflated_fare 	dropoff_manhattan 	pickup_manhattan 	weekend

# For NN
# Keep whole dataset
df_x_nn = df[['pickup_longitude','dropoff_longitude','pickup_latitude',
              'dropoff_latitude','passenger_count','year','weekday','weekend','hour_sin','month_sin',
              'delta_longitude','delta_latitude','distance_km','direction',
              'dropoff_manhattan','pickup_manhattan','peak_hours','JFK','LGA',
              'NWK']].copy().astype(float)
df_y_nn = df['fare_amount'].copy()
# Split the data
x_train_nn, x_test_nn, y_train_nn, y_test_nn = train_test_split(df_x_nn, df_y_nn, test_size=0.2, random_state=42)

# For all ML algorithms except NN
# Keep only 20% of dataset and choose randomly
df_x, df_x_drop, df_y, df_y_drop = train_test_split(df_x_nn, df_y_nn, test_size=0.87, random_state=42)
df_x = df_x[['passenger_count','year','weekday','hour_sin','delta_longitude',
             'delta_latitude','distance_km','direction','dropoff_manhattan',
             'pickup_manhattan','peak_hours','JFK','LGA','NWK']].copy().astype(float)
# Split the data
x_train, x_test, y_train, y_test = train_test_split(df_x, df_y, test_size=0.2, random_state=42)

print(df_x.shape)
print(df_x_nn.shape)

# Dataframe to append ml algorithm evaluations for plotting
evaluation_df = pd.DataFrame({'name': [], 'mae': [], 'rmse': []})
# List to append ml algorithm Mean Absolute Error intervals for plotting
intervals_list = []

# The baseline predictions are the historical averages
# Baseline errors, and display average baseline error

baseline_preds = y_test.mean()
baseline_errors = abs(baseline_preds - y_test)
print('Average baseline error: ', round(np.mean(baseline_errors), 2))

"""## Functions"""

# Function to plot Mean Absolute Error intervals
def plot_intervals(interv_list):
  plt.figure(figsize=(15,5))
  interval_df=pd.DataFrame(interv_list,columns=['name','<1 $','<2 $','<3 $','<4 $','<5 $','<6 $','<7 $','<8 $','<9 $','<10 $'])
  plt.tight_layout()
  fig, ax = plt.subplots(figsize=(15,5))
  for i in range(0,len(interval_df.index)):
    ax.plot(interval_df.iloc[i,1:], label=interval_df.iloc[i,0])
  ax.legend(loc='lower right')
  plt.xlabel('Intervals')
  plt.title('Mean Absolute Error Intervals')


# Function to get Mean Absolute Error intervals
def get_intervals(name, err):
  samples_i=[]
  for i in range(1,11):
    samples_i.append(sum((err<=i)==True))
  scaled_samples_i = np.asarray(samples_i)/len(err)
  l = scaled_samples_i.tolist()
  l.insert(0, name)
  return l


# Function to fill a dataframe for evaluation of ML algorithms
def fill_df_for_evaluation(name, mae, rmse):
  return {'name' : name, 'mae' : mae, 'rmse' : rmse}


def add_results_to_df(name, predictions, y_test):
    global evaluation_df, intervals_list
    mae = metrics.mean_absolute_error(y_test, predictions)
    print('Mean Absolute Error:', mae)
    rmse = np.sqrt(metrics.mean_squared_error(y_test, predictions))
    print('Root Mean Squared Error:', rmse)
    errors = abs(predictions - y_test)

    new_row = fill_df_for_evaluation(name, mae, rmse)
    new_df = pd.DataFrame([new_row])

    evaluation_df = pd.concat([evaluation_df, new_df], ignore_index=True)
    intervals_list.append(get_intervals(name, errors))


# Function to create plot of Root Mean Squared Error of ML algorithms
def create_rmse_plot(evaluation_df):
  plt.figure(figsize = (12,5))
  eval_df = evaluation_df.sort_values(by=['rmse'], ascending=False)
  ax = sns.barplot(x=eval_df.name, y=eval_df.rmse)
  plt.xlabel('ML Algorithms')
  plt.xlabel('RMSE')
  plt.title('Root Mean Squared Error of ML algorithms');
  plt.tight_layout()
  plt.show()


# Function to create plot of Mean Absolute Error of ML algorithms
def create_mae_plot(evaluation_df):
  plt.figure(figsize = (12,5))
  eval_df = evaluation_df.sort_values(by=['mae'], ascending=False)
  ax = sns.barplot(x=eval_df.name, y=eval_df.mae)
  plt.xlabel('ML Algorithms')
  plt.ylabel('MAE ($)')
  plt.title('Mean Absolute Error of ML algorithms');
  plt.tight_layout()
  plt.show()

accuracy_df = pd.DataFrame(columns=['Model', 'Accuracy'])

"""## Algorithms

### Linear Regression

LinearRegression fits a linear model with coefficients w = (w1, …, wp) to minimize the residual sum of squares between the observed targets in the dataset, and the targets predicted by the linear approximation.
"""

# StandardScaler + linear + Pipe
scaler = StandardScaler()
model = linear_model.LinearRegression(n_jobs=-1)
pipe = Pipeline(steps=[('scaler', scaler), ('model', model)], memory = 'tmp')

start_time = time.time()
pipe.fit(x_train,y_train)
predictions = pipe.predict(x_test)
print("Total time fit and predict: %s seconds" % (time.time() - start_time))

add_results_to_df('linear_regression',predictions,y_test)

def calculate_accuracy_regression(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy

# Define your threshold here
threshold = 10

# Calculate predictions
predictions = pipe.predict(x_test)

# Calculate accuracy
accuracy = calculate_accuracy_regression(predictions, y_test, threshold)
print("Accuracy of Linear Regression with StandardScaler:", accuracy*100)
new_row = pd.DataFrame({'Model': "Linear Regression", 'Accuracy': [accuracy*100]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""### Random Forest

A random forest regressor.
A random forest is a meta estimator that fits a number of classifying decision trees on various sub-samples of the dataset and uses averaging to improve the predictive accuracy and control over-fitting.
"""

# StandardScaler + rf + Pipe
scaler = StandardScaler()
# Instantiate model with 1000 decision trees
rf = RandomForestRegressor(n_estimators = 1000, random_state = 42, n_jobs=-1)
pipe = Pipeline(steps=[('scaler', scaler), ('rf', rf)], memory = 'tmp')

start_time = time.time()
pipe.fit(x_train,y_train)
predictions = pipe.predict(x_test)
print("Total time fit and predict: %s seconds" % (time.time() - start_time))

add_results_to_df('random_forest',predictions,y_test)
del rf
gc.collect()
def calculate_accuracy_regression(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy

# Define your threshold here
threshold = 10

# Calculate predictions
predictions = pipe.predict(x_test)

# Calculate accuracy
accuracy = calculate_accuracy_regression(predictions, y_test, threshold)
print("Accuracy of Random Forest with StandardScaler:", accuracy*100)
new_row = pd.DataFrame({'Model': "Random Forest", 'Accuracy': [accuracy*100]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""

```
# This is formatted as code
```

### Epsilon-Support Vector Regression

The free parameters in the model are C and kernel type"""

# Hyperparemeters selected after tuning
kernel = 'rbf'
C = 3

clf = SVR(kernel=kernel,C=C)
scaler = StandardScaler()

pipe = Pipeline(steps=[('scaler', scaler),('SVR', clf)])
start_time = time.time()
pipe.fit(x_train, y_train)
preds = pipe.predict(x_test)
print("Total time fit and predict: %s seconds" % (time.time() - start_time))

add_results_to_df('linear_svr',preds,y_test)

def calculate_accuracy_regression(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy

# Define your threshold here
threshold = 9

# Calculate predictions
preds = pipe.predict(x_test)

# Calculate accuracy
accuracy = calculate_accuracy_regression(preds, y_test, threshold)
print("Accuracy of Linear SVR with StandardScaler:", accuracy*100)
new_row = pd.DataFrame({'Model': "Support Vector Regression", 'Accuracy': [accuracy*100]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""### XGBoost

XGBoost (Extreme Gradient Boosting) belongs to a family of boosting algorithms and uses the gradient boosting (GBM) framework at its core. It is an optimized distributed gradient boosting library.
"""

#StandardScaler + xgboost + Pipe with parameters after using RandomizedSearchCV
scaler = StandardScaler()
xgb_model = xgb.XGBRegressor(n_estimators=300, learning_rate=0.11, gamma=0.003, subsample=0.91, colsample_bytree=0.69, max_depth=5)
pipe = Pipeline(steps=[('scaler', scaler), ('xgb', xgb_model)], memory = 'tmp')

start_time = time.time()
pipe.fit(x_train,y_train)
predictions = pipe.predict(x_test)
print("Total time fit and predict: %s seconds" % (time.time() - start_time))

add_results_to_df('xgboost',predictions,y_test)

def calculate_accuracy_regression(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy

# Define your threshold here
threshold = 10

# Calculate predictions
predictions = pipe.predict(x_test)

# Calculate accuracy
accuracy = calculate_accuracy_regression(predictions, y_test, threshold)
print("Accuracy of XGBoost with StandardScaler:", accuracy*100)
new_row = pd.DataFrame({'Model': "XGBoost", 'Accuracy': [accuracy*100]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""### Voting Regressor
Prediction voting regressor for unfitted estimators.

A voting regressor is an ensemble meta-estimator that fits base regressors each on the whole dataset. It, then, averages the individual predictions to form a final prediction.
"""

kernel = 'rbf'
C = 3

sv = SVR(kernel=kernel,C=C)
rf = RandomForestRegressor(n_estimators = 1000, random_state = 42, n_jobs=-1)
xg = xgb.XGBRegressor(n_estimators=108, learning_rate=0.11, gamma=0.003, subsample=0.91, colsample_bytree=0.69, max_depth=5)
scaler = StandardScaler()
clf = VotingRegressor([('rf', rf), ('xg', xg),('sv',sv)])

pipe = Pipeline(steps=[('scaler', scaler),('clf', clf)])

start_time = time.time()
pipe.fit(x_train, y_train)
preds = pipe.predict(x_test)
print("Total time fit and predict: %s seconds" % (time.time() - start_time))

add_results_to_df('voting_regressor',preds,y_test)

def calculate_accuracy_regression(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy

# Define your threshold here
threshold = 10

# Calculate predictions
preds = pipe.predict(x_test)

# Calculate accuracy
accuracy = calculate_accuracy_regression(preds, y_test, threshold)
print("Accuracy of Voting Regressor:", accuracy*100)
new_row = pd.DataFrame({'Model': "Voting Regressor", 'Accuracy': [accuracy*100]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""### Bagging Regressor

A Bagging regressor is an ensemble meta-estimator that fits base regressors each on random subsets of the original dataset and then aggregate their individual predictions (either by voting or by averaging) to form a final prediction. Such a meta-estimator can typically be used as a way to reduce the variance of a black-box estimator (e.g., a decision tree), by introducing randomization into its construction procedure and then making an ensemble out of it.
"""

scaler = StandardScaler()
regr = BaggingRegressor(base_estimator=SVR(),n_estimators=7, random_state=42)
pipe = Pipeline(steps=[('scaler', scaler),('regr', regr)])

start_time = time.time()
pipe.fit(x_train,y_train)
preds = pipe.predict(x_test)
print("Total time fit and predict: %s seconds" % (time.time() - start_time))

add_results_to_df('bagging_regressor',preds,y_test)

def calculate_accuracy_regression(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy

# Define your threshold here
threshold = 8

# Calculate predictions
preds = pipe.predict(x_test)

# Calculate accuracy
accuracy = calculate_accuracy_regression(preds, y_test, threshold)
print("Accuracy of Bagging Regressor with SVR base estimator:", accuracy*100)
new_row = pd.DataFrame({'Model': "Bagging Regressor", 'Accuracy': [accuracy*100]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""### Histogram-based Gradient Boosting Regression Tree

This implementation is inspired by LightGBM.
This estimator has native support for missing values (NaNs). During training, the tree grower learns at each split point whether samples with missing values should go to the left or right child, based on the potential gain. When predicting, samples with missing values are assigned to the left or right child consequently. If no missing values were encountered for a given feature during training, then samples with missing values are mapped to whichever child has the most samples.
"""

start_time = time.time()
est = HistGradientBoostingRegressor().fit(x_train, y_train).fit(x_train,y_train)
preds = est.predict(x_test)
print("Total time fit and predict: %s seconds" % (time.time() - start_time))

add_results_to_df('histogram_grad_boost_reg',preds,y_test)

def calculate_accuracy_regression(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy

# Define your threshold here
threshold = 10

# Calculate predictions
preds = est.predict(x_test)

# Calculate accuracy
accuracy = calculate_accuracy_regression(preds, y_test, threshold)
print("Accuracy of Histogram Gradient Boosting Regressor:", accuracy*100)
new_row = pd.DataFrame({'Model': "Histogram-base Regression", 'Accuracy': [accuracy*100]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""### Neural Network
A neural network is expected to give one of the best potential results. It has to be fed a huge amount of data, so the dataset that will be used to train it, will be roughly 10 times larger. A multilayere network is used. Attempts were made with 1-hot encoding, as well as early stopping. However, the simple version ended up giving the best result. It was decided that all characteristics are to be used, and let the network decide their importance.

The following network projects the input into a increasingly larger space, in order to extract any high level characteristics, and then attempts to guess the value of the taxi fare.
"""

#!pip install --upgrade tensorflow==1.15
#!pip install --upgrade keras

# Standard Scaling data
x_train_nn[x_train_nn.columns] = scaler.fit_transform(x_train_nn[x_train_nn.columns])
x_test_nn[x_test_nn.columns] = scaler.fit_transform(x_test_nn[x_test_nn.columns])

def build_model():
  model = Sequential()
  model.add(Dense(48, activation='relu', input_dim=20))
  model.add(Dense(96, activation='relu'))
  model.add(Dense(48, activation='relu'))
  model.add(Dense(24, activation='relu'))
  model.add(Dense(12, activation='relu'))
  model.add(Dense(6,  activation='relu'))
  model.add(Dense(1,  activation='relu'))

  optimizer = opt.RMSprop()
  model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mean_squared_error', 'mean_absolute_error'])
  return model

def calculate_accuracy(predictions, true_values, threshold):
    errors = abs(predictions - true_values)
    correct_predictions = (errors <= threshold).sum()
    total_predictions = len(predictions)
    accuracy = correct_predictions / total_predictions
    return accuracy*100

# create model
model = build_model()

# The patience parameter is the amount of epochs to check for improvement
early_stop = keras.callbacks.EarlyStopping(monitor='val_loss', patience=10)

# train model
epochs = 20
batch_size = 32

start_time = time.time()
history = model.fit(
  x_train_nn, y_train_nn, epochs=epochs, batch_size=batch_size,  callbacks=[early_stop])
# Plot metrics
plt.plot(history.history['mean_squared_error'])
plt.plot(history.history['mean_absolute_error'])
plt.show()

loss, mse, mae = model.evaluate(x_test_nn, y_test_nn, verbose=2, batch_size=batch_size)
print("Total time fit and evaluate: %s seconds" % (time.time() - start_time))


new_row = fill_df_for_evaluation("neural_network", mae, np.sqrt(mse))
new_df = pd.DataFrame([new_row])
evaluation_df = pd.concat([evaluation_df, new_df], ignore_index=True)
print("Testing set Mean Abs Error: {:5.3f} $".format(mae))
print("Testing set Mean Squared Error: {:5.3f}".format(mse))
print("Testing set Root Mean Squared Error: {:5.3f}".format(np.sqrt(mse)))
threshold = 10  # Define your threshold here
predictions_cnn = model.predict(x_test_nn)  # Assuming `model` is your trained CNN model
errors_cnn = abs(predictions_cnn.flatten() - y_test_nn)
accuracy_cnn = calculate_accuracy(predictions_cnn.flatten(), y_test_nn, threshold)
print("CNN Model Accuracy:", accuracy_cnn)
new_row = pd.DataFrame({'Model': "Neural Network", 'Accuracy': [accuracy_cnn]})
accuracy_df = pd.concat([accuracy_df, new_row], ignore_index=True)

"""## Results

Plot Root Mean Squared Error for each ML algorithm
"""

create_rmse_plot(evaluation_df)

"""Plot Mean Absolute Error each ML algorithm"""

create_mae_plot(evaluation_df)

"""Plot MAE Error Intervals for each ML algorithm"""

plot_intervals(intervals_list)

print(accuracy_df)

plt.figure(figsize=(10, 6))
plt.bar(accuracy_df['Model'], accuracy_df['Accuracy'], color='skyblue')
plt.xlabel('Model')
plt.ylabel('Accuracy')
plt.title('Accuracy of Regression Models')
plt.xticks(rotation=90)
plt.ylim(50, 100)  # Set y-axis limit from 0 to 1
plt.grid(axis='y')  # Add gridlines on the y-axis
plt.tight_layout()
plt.show()

# Find the algorithm with the highest accuracy
best_model = accuracy_df.loc[accuracy_df['Accuracy'].idxmax()]

print("Best performing algorithm:")
print(best_model)